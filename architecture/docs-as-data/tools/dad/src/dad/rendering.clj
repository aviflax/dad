(ns dad.rendering
  (:require [clojure.java.io :refer [file]]
            [clojure.string :as str :refer [lower-case]]
            [dad.files :as files :refer [relative-path]]
            [dad.yaml :as yaml]
            [medley.core :as mc]
            [selmer.filters :as filters]
            [selmer.parser :as parser :refer [render]])
  (:import [java.time ZonedDateTime]))

(defn- flexi-get
  ([coll k]
   (flexi-get coll k nil))
  ([coll k d]
   (or (get coll k)
       (get coll (name k))
       (get coll (lower-case (name k)))
       (get coll (keyword (lower-case (name k))))
       d)))

(defn- flex=
  [& vs]
  (apply = (map (comp lower-case name) vs)))

(def filters
  ;; TODO: some of these names are iffy. Rethink!
  {:filter-by (fn [m k v]
                (->> m
                     (mc/filter-vals (fn [im] (flex= (flexi-get im k) v)))
                     (into (empty m))))
   :get flexi-get

   ;; This needs to produce the same slugs that GitHub generates when rendering Markdown into HTML.
   ;; (GH generates “permalinks” for every Markdown header; the anchor is a slugified version of
   ;; the header text.)
   ;; We should probably replace this sketchy impl with one from a third-party library.
   :slugify #(some-> %
                     (name)
                     (lower-case)
                     (str/replace #"\s" "-")
                     (str/replace #"[^-_A-Za-z0-9]" ""))

   :parse-date-time #(try (when-not (str/blank? %) (ZonedDateTime/parse %))
                          (catch Exception _e nil))

   ; This name isn’t clear. It’s really sort-by-nested-key as it assumes that the input is a coll
   ; of maps. Gotta figure this out.
   :sort-by-key (fn [coll k]
                  (into (empty coll)
                        (sort-by (fn [[_k v]] (lower-case (flexi-get v k)))
                                 coll)))
   :sort-by-keys #(into (empty %)
                        (sort-by (fn [[k _v]] (lower-case (name k))) %))
   :sort-by-names (fn [coll]
                    (sort-by (fn [[k v]]
                               (lower-case (flexi-get v "full-name" (name k))))
                             coll))
   :without (fn [coll k]
              (remove (fn [[_name props]]
                        (or (contains? props k)
                            (contains? props (keyword k))))
                      coll))})

(defn- register-filters!
  []
  (doseq [[n f] filters]
    (filters/add-filter! n f)))

(defn- reduce-whitespace
  "Selmer doesn’t have any whitespace control features, so we use this function in post-processing
  to remove some extraneous whitespace. If/when the solution described here:
  https://github.com/yogthos/Selmer/issues/170#issuecomment-594778666 is addressed, we can reassess
  this function."
  [s]
  (-> ;; For now we’ve hacked in our own whitespace control, which operates on the result of
      ;; Selmer’s rendering. Any trailing whitespace will be removed from any line that ends with 🆇
      ;; will be removed, along with the 🆇 and the newline. If the line was blank then it will
      ;; therefore be removed altogether. If it wasn’t blank then its contents will effectively be
      ;; merged with the following line. Sorry if this isn’t clear; it’s hard to explain.
      (str/replace s #"[ \t]*🆇\n" "")

      ;; TODO
      (str/replace #"[ \t]*⌫" "")

      ; Selmer rendering tends to yield a ton of extra whitespace, which can cause problems when
      ; rendering Markdown. So we collapse down one or more blank lines followed stretches of
      ; whitespace into a single blank line with no leading whitespace.
      (str/replace #"\n\s*\n *" "\n\n")

      ; Collapse 2 or more blank lines into a single blank line.
      (str/replace #"\n{3,}" "\n\n")))

(defn- warning-header
  [template-path repo-root-dir]
  (-> ["<!--"
        ""
        "WARNING WARNING WARNING"
        ""
        "This file is AUTOMATICALLY generated from a template. If you change its contents,"
        "your changes WILL be lost when the file is regenerated — so DON’T DO THAT."
        ""
        "SERIOUSLY."
        ""
        "Source template: <repo-root>/%s"
        ""
        "-->\n\n"]
       (->> (interpose "\n")
            (apply str))
       (format (str (relative-path repo-root-dir template-path)))))

(defn- parse-rendered
  "Accepts a rendered string, returns a sequence of maps containing :dad/front-matter — the parsed
  front matter — and :dad/body — the body of the rendered doc.

  If the doc contains multiple bodies, each front-matter map must have the key `path` containing the
  output path to which the doc body should be written. If it does not, an exception will be thrown.

  If the doc contains a single body then the front-matter is optional and :dad/front-matter may be nil.

  The value of path is relative to the location of the document template, unless it starts with a
  `/` in which case it’s relative to the root of the output-dir."
  [rendered]
  (let [split (str/split rendered #"\n---\n")]
    (if (= (count split) 1)
      (vector {:dad/front-matter nil
               :dad/body rendered})
      (->> (remove str/blank? split) ;; Java regex split returns a blank first elem if the string starts with the delimiter
           (partition 2)
           (map (fn [[front-matter main-doc]]
                  (let [fm (yaml/parse-string front-matter)]
                    (if (:path fm)
                      {:dad/front-matter fm
                       :dad/body main-doc}
                      (throw (ex-info (str "All docs in multi-body templates must have the key"
                                           " `path` in their front-matter.")
                                      {:dad/front-matter fm :dad/body main-doc}))))))))))

(defn build-docs
  "Returns a sequence of maps with [:dad/template-path :dad/front-matter :dad/body].

  NB: the values of :dad/template-path are relative to templates-path. In other words, they don’t
  contain templates-path."
  [db templates-dir repo-root-dir]
  (register-filters!)
  (->> (file-seq (file templates-dir))
       (filter (memfn isFile)) ;; TODO: this breaks if there’s a binary file, e.g. .DS_Store

       ;; Render template, wrap result in a map along with the template path
       (map #(hash-map :dad/template-path %
                       :dad/body (render (slurp %) db)))

       ;; Parse each rendered body into potentially multiple docs. Whether the result is one map
       ;; or one thousand, each map will also have the key :dad/front-matter although its value
       ;; might be nil.
       (mapcat (fn [{:keys [:dad/body] :as in}]
                 (->> (parse-rendered body)
                      (map #(merge in %)))))

       ;; Reduce whitespace
       (map #(update % :dad/body reduce-whitespace))

       ;; Add warning header to each body
       (map (fn [{:keys [:dad/template-path] :as doc}]
              (update doc :dad/body #(str (warning-header template-path repo-root-dir) %))))))
