(ns dad.rendering
  (:require [clojure.java.io :refer [file]]
            [clojure.string :as str]
            [dad.files :as files :refer [relative-path]]
            [dad.yaml :as yaml]
            [dad.rendering.filters :as filters]
            [dad.rendering.tags :as tags]
            [selmer.parser :as parser :refer [render]])
  (:import [java.io File]))

(set! *warn-on-reflection* true)

(defn- reduce-whitespace
  "Selmer doesnâ€™t have any whitespace control features, so we use this function in post-processing
  to remove some extraneous whitespace. If/when the solution described here:
  https://github.com/yogthos/Selmer/issues/170#issuecomment-594778666 is addressed, we can reassess
  this function."
  [s]
  (-> ;; For now weâ€™ve hacked in our own whitespace control, which operates on the result of
      ;; Selmerâ€™s rendering. Any trailing whitespace will be removed from any line that ends with ðŸ†‡
      ;; will be removed, along with the ðŸ†‡ and the newline. If the line was blank then it will
      ;; therefore be removed altogether. If it wasnâ€™t blank then its contents will effectively be
      ;; merged with the following line. Sorry if this isnâ€™t clear; itâ€™s hard to explain.
      (str/replace s #"[ \t]*ðŸ†‡\n" "")

      ;; TODO
      (str/replace #"[ \t]*âŒ«" "")

      ; Selmer rendering tends to yield a ton of extra whitespace, which can cause problems when
      ; rendering Markdown. So we collapse down one or more blank lines followed stretches of
      ; whitespace into a single blank line with no leading whitespace.
      (str/replace #"\n\s*\n *" "\n\n")

      ; Collapse 2 or more blank lines into a single blank line.
      (str/replace #"\n{3,}" "\n\n")))

(defn- warning-header
  "Builds and returns a warning header as a string. The header is guaranteed to contain the
  substring `AUTOMATICALLY generated from a template` â€” downstream projects may use this to identify
  generated docs." ;; SO if you change this function, DO NOT change that substring!
  [template-path repo-root-dir]
  (-> ["<!--"
        ""
        "WARNING WARNING WARNING"
        ""
        "This file is AUTOMATICALLY generated from a template. If you change its contents,"
        "your changes WILL be lost when the file is regenerated â€” so DONâ€™T DO THAT."
        ""
        "SERIOUSLY."
        ""
        "Source template: <repo-root>/%s"
        ""
        "-->\n\n"]
       (->> (interpose "\n")
            (apply str))
       (format (str (relative-path repo-root-dir template-path)))))

(defn- parse-rendered
  "Accepts a rendered string, returns a sequence of maps containing :dad/front-matter â€” the parsed
  front matter â€” and :dad/body â€” the body of the rendered doc.

  If the doc contains multiple bodies, each front-matter map must have the key `path` containing the
  output path to which the doc body should be written. If it does not, an exception will be thrown.

  If the doc contains a single body then the front-matter is optional and :dad/front-matter may be nil.

  The value of path is relative to the location of the document template, unless it starts with a
  `/` in which case itâ€™s relative to the root of the output-dir."
  [rendered]
  (let [split (str/split rendered #"\n---\n")]
    (if (= (count split) 1)
      (vector {:dad/front-matter nil
               :dad/body rendered})
      (->> (remove str/blank? split) ;; Java regex split returns a blank first elem if the string starts with the delimiter
           (partition 2)
           (map (fn [[front-matter main-doc]]
                  (let [fm (yaml/parse-string front-matter)]
                    (if (:path fm)
                      {:dad/front-matter fm
                       :dad/body main-doc}
                      (throw (ex-info (str "All docs in multi-body templates must have the key"
                                           " `path` in their front-matter.")
                                      {:dad/front-matter fm :dad/body main-doc}))))))))))

(defn build-docs
  "Returns a sequence of maps with [:dad/template-path :dad/front-matter :dad/body].

  NB: the values of :dad/template-path are relative to templates-path. In other words, they donâ€™t
  contain templates-path."
  [db templates-dir repo-root-dir]
  (filters/register!)
  (tags/register!)
  (->> (file-seq (file templates-dir))
       (filter (fn [^File fp] (.isFile fp))) ;; TODO: this breaks if thereâ€™s a binary file, e.g. .DS_Store

       ;; Render template, wrap result in a map along with the template path
       (map #(hash-map :dad/template-path %
                       :dad/body (render (slurp %) db)))

       ;; Parse each rendered body into potentially multiple docs. Whether the result is one map
       ;; or one thousand, each map will also have the key :dad/front-matter although its value
       ;; might be nil.
       (mapcat (fn [{:keys [:dad/body] :as in}]
                 (->> (parse-rendered body)
                      (map #(merge in %)))))

       ;; Reduce whitespace
       (map #(update % :dad/body reduce-whitespace))

       ;; Add warning header to each body
       (map (fn [{:keys [:dad/template-path] :as doc}]
              (update doc :dad/body #(str (warning-header template-path repo-root-dir) %))))))
